import os
import glob
import zipfile
import tempfile
import numpy as np
import rasterio
from rasterio.windows import Window
from rasterio.vrt import WarpedVRT
from rasterio.enums import Resampling
from rasterio import features as rast_features
import geopandas as gpd
from sklearn.ensemble import RandomForestClassifier
from scipy.ndimage import generic_filter
from contextlib import ExitStack
import gc

# ==================== 設定エリア ====================

# 1. 衛星画像があるフォルダのリスト (5時期)
base_dirs = [
    r"G:\SATELITEIMAGE\RABI\MP\2025SENTINEL2\20241114",
    r"G:\SATELITEIMAGE\RABI\MP\2025SENTINEL2\20241219",
    r"G:\SATELITEIMAGE\RABI\MP\2025SENTINEL2\20250118",
    r"G:\SATELITEIMAGE\RABI\MP\2025SENTINEL2\20250202",
    r"G:\SATELITEIMAGE\RABI\MP\2025SENTINEL2\20250319"
]

# 2. 教師データ (.scpx) のパス
scpx_path = r"G:\SATELITEIMAGE\RABI\MP\2025SENTINEL2\multiforestbunnruidata.scpx"

# 3. 結果を保存するファイル名
# NDBIを追加した最終版
output_tif = r"G:\SATELITEIMAGE\RABI\MP\2025SENTINEL2\classification_result_RF_Final_NDBI.tif"

# ====================================================

def get_band_path(directory, band_name):
    """指定されたフォルダから特定のバンドファイルを検索する"""
    search_patterns = [
        os.path.join(directory, "**", f"*{band_name}*.jp2"),
        os.path.join(directory, "**", f"*{band_name}*.tif"),
        os.path.join(directory, "**", f"*{band_name}*.TIF")
    ]
    for pattern in search_patterns:
        files = glob.glob(pattern, recursive=True)
        valid_files = [f for f in files if "TCI" not in f and "PVI" not in f]
        if valid_files:
            return valid_files[0]
    return None

def calculate_indices(b2, b3, b4, b8, b11, b12):
    """
    全要素（Reflectance, NDVI, NDWI, Texture, NDBI）を計算してスタックする
    """
    epsilon = 1e-6
    
    # 1. NDVI (植生指数)
    ndvi = (b8 - b4) / (b8 + b4 + epsilon)
    
    # 2. NDWI (水指数)
    ndwi = (b3 - b8) / (b3 + b8 + epsilon)
    
    # 3. Texture (表面の粗さ)
    texture = generic_filter(b8, np.std, size=3)

    # 4. 【追加】NDBI (都市指数)
    # Built-up Areas を強調する
    ndbi = (b11 - b8) / (b11 + b8 + epsilon)
    
    # スタック順序: 合計10バンド
    return np.stack([b2, b3, b4, b8, b11, b12, ndvi, ndwi, texture, ndbi])

def add_temporal_differences(X_stack):
    """時期間の差分を追加特徴量として計算する"""
    idx_jan = 2 # 20250118
    idx_feb = 3 # 20250202
    idx_mar = 4 # 20250319
    
    # 1時期あたりのバンド数 (calculate_indicesで返した数)
    # NDBIが増えたので 9 -> 10 に変更
    bands_per_date = 10
    
    # NIR(B8)の位置 (index 3)
    offset_nir = 3
    nir_jan = X_stack[:, idx_jan * bands_per_date + offset_nir]
    nir_feb = X_stack[:, idx_feb * bands_per_date + offset_nir]
    nir_mar = X_stack[:, idx_mar * bands_per_date + offset_nir]

    # NDVIの位置 (index 6)
    offset_ndvi = 6
    ndvi_jan = X_stack[:, idx_jan * bands_per_date + offset_ndvi]
    ndvi_mar = X_stack[:, idx_mar * bands_per_date + offset_ndvi]

    # 差分計算
    diff_nir_mar_jan = nir_mar - nir_jan
    diff_nir_mar_feb = nir_mar - nir_feb
    diff_ndvi_mar_jan = ndvi_mar - ndvi_jan

    # 結合
    return np.column_stack([X_stack, diff_nir_mar_jan, diff_nir_mar_feb, diff_ndvi_mar_jan])


# --- メイン処理 ---

print("処理を開始します（Final Version with NDBI）...")

# 0. 基準プロファイルの取得
ref_path = get_band_path(base_dirs[0], "B02")
if not ref_path: raise ValueError("基準画像(B02)が見つかりません")

with rasterio.open(ref_path) as src0:
    profile = src0.profile
    h, w = src0.height, src0.width
    crs = src0.crs
    transform = src0.transform

# 1. 教師データの読み込み
print(f"教師データを読み込んでいます...")
gdf = None
with tempfile.TemporaryDirectory() as temp_dir:
    with zipfile.ZipFile(scpx_path, 'r') as zip_ref:
        gpkg_name = next((f for f in zip_ref.namelist() if f.endswith('.gpkg')), None)
        if gpkg_name:
            zip_ref.extract(gpkg_name, temp_dir)
            gdf = gpd.read_file(os.path.join(temp_dir, gpkg_name))
            if gdf.crs != crs: gdf = gdf.to_crs(crs)

if gdf is None: raise ValueError("教師データ読み込み失敗")
target_col = next((c for c in ['class_id', 'C_ID', 'id', 'Class_ID'] if c in gdf.columns), None)

# 2. 学習データの抽出
print("学習データを抽出中...")

shapes = ((geom, value) for geom, value in zip(gdf.geometry, gdf[target_col]))
roi_mask_full = rast_features.rasterize(shapes=shapes, out_shape=(h, w), transform=transform, dtype=np.uint8)

X_train_list = []
y_train_list = []
extract_block_size = 1024 

# 各時期ごとの処理
for date_idx, directory in enumerate(base_dirs):
    print(f"  - 時期 {date_idx+1}/{len(base_dirs)}: {os.path.basename(directory)}")
    
    p_b2 = get_band_path(directory, "B02") or get_band_path(directory, "B2")
    p_b3 = get_band_path(directory, "B03") or get_band_path(directory, "B3")
    p_b4 = get_band_path(directory, "B04") or get_band_path(directory, "B4")
    p_b8 = get_band_path(directory, "B08") or get_band_path(directory, "B8")
    p_b11 = get_band_path(directory, "B11")
    p_b12 = get_band_path(directory, "B12")
    
    if not all([p_b2, p_b3, p_b4, p_b8, p_b11, p_b12]): continue

    date_features_list = []
    
    def open_vrt(path):
        src = rasterio.open(path)
        return WarpedVRT(src, crs=crs, transform=transform, width=w, height=h, resampling=Resampling.bilinear)

    with ExitStack() as stack:
        vrt_b2 = stack.enter_context(open_vrt(p_b2))
        vrt_b3 = stack.enter_context(open_vrt(p_b3))
        vrt_b4 = stack.enter_context(open_vrt(p_b4))
        vrt_b8 = stack.enter_context(open_vrt(p_b8))
        vrt_b11 = stack.enter_context(open_vrt(p_b11))
        vrt_b12 = stack.enter_context(open_vrt(p_b12))

        for i in range(0, h, extract_block_size):
            for j in range(0, w, extract_block_size):
                window = Window(j, i, min(extract_block_size, w - j), min(extract_block_size, h - i))
                mask_block = roi_mask_full[window.row_off:window.row_off+window.height, 
                                         window.col_off:window.col_off+window.width]
                
                if not np.any(mask_block > 0): continue 
                
                b2 = vrt_b2.read(1, window=window).astype(np.float32)
                b3 = vrt_b3.read(1, window=window).astype(np.float32)
                b4 = vrt_b4.read(1, window=window).astype(np.float32)
                b8 = vrt_b8.read(1, window=window).astype(np.float32)
                b11 = vrt_b11.read(1, window=window).astype(np.float32)
                b12 = vrt_b12.read(1, window=window).astype(np.float32)
                
                # 全要素計算 (NDBI含む)
                feats = calculate_indices(b2, b3, b4, b8, b11, b12)
                
                valid_pixels = (mask_block > 0)
                extracted = feats[:, valid_pixels].T
                date_features_list.append(extracted)
                
                if date_idx == 0:
                    y_train_list.append(mask_block[valid_pixels])

    if date_features_list:
        X_train_list.append(np.vstack(date_features_list))
    
    gc.collect()

# データの結合
print("全データを結合し、時系列差分を計算中...")
min_len = min([len(x) for x in X_train_list] + [len(np.hstack(y_train_list))])
X_train = np.hstack([x[:min_len] for x in X_train_list])
y_train = np.hstack(y_train_list)[:min_len]
X_train = np.nan_to_num(X_train)

# 【差分特徴量の追加】
X_train = add_temporal_differences(X_train)

print(f"学習データ準備完了: {X_train.shape[0]} 点, 次元数: {X_train.shape[1]}")

# 3. AI学習
print("AIモデルを学習中 (class_weight='balanced')...")
rf = RandomForestClassifier(n_estimators=200, n_jobs=-1, random_state=42, class_weight='balanced')
rf.fit(X_train, y_train)
print("学習完了！")

# 4. 全画面分類
print(f"全画像の分類を開始します... 出力先: {output_tif}")

profile.update(driver='GTiff', count=1, dtype=rasterio.uint8, nodata=0, compress='lzw', tiled=True, blockxsize=256, blockysize=256)
rf.n_jobs = 1 
process_block_size = 512

with rasterio.open(output_tif, 'w', **profile) as dst:
    total_rows = (h // process_block_size) + 1
    row_count = 0
    
    for i in range(0, h, process_block_size):
        row_count += 1
        print(f"    - 分類進捗: {row_count}/{total_rows} 行目...", end="\r")
        
        for j in range(0, w, process_block_size):
            window = Window(j, i, min(process_block_size, w - j), min(process_block_size, h - i))
            win_h, win_w = window.height, window.width
            
            block_features_list = []
            
            for directory in base_dirs:
                p_b2 = get_band_path(directory, "B02") or get_band_path(directory, "B2")
                p_b3 = get_band_path(directory, "B03") or get_band_path(directory, "B3")
                p_b4 = get_band_path(directory, "B04") or get_band_path(directory, "B4")
                p_b8 = get_band_path(directory, "B08") or get_band_path(directory, "B8")
                p_b11 = get_band_path(directory, "B11")
                p_b12 = get_band_path(directory, "B12")
                
                if not all([p_b2, p_b3, p_b4, p_b8, p_b11, p_b12]): continue

                def read_win(p):
                    with rasterio.open(p) as src:
                        with WarpedVRT(src, crs=crs, transform=transform, width=w, height=h, resampling=Resampling.bilinear) as vrt:
                            return vrt.read(1, window=window).astype(np.float32)

                wb2 = read_win(p_b2)
                wb3 = read_win(p_b3)
                wb4 = read_win(p_b4)
                wb8 = read_win(p_b8)
                wb11 = read_win(p_b11)
                wb12 = read_win(p_b12)
                
                w_feats = calculate_indices(wb2, wb3, wb4, wb8, wb11, wb12)
                w_feats_flat = w_feats.reshape(10, -1).T # NDBIが増えたので10
                block_features_list.append(w_feats_flat)
            
            if not block_features_list: continue

            X_block = np.hstack(block_features_list)
            X_block = np.nan_to_num(X_block)
            X_block = add_temporal_differences(X_block)
            
            y_pred = rf.predict(X_block)
            dst.write(y_pred.reshape(win_h, win_w).astype(rasterio.uint8), 1, window=window)
        
        gc.collect()

print("\n=== 全処理完了 ===")
